[
  {"order": 0,"title":"Introduction","texts": ["Nim is a relatively new programming language which allows users to write easy-to-read high-performance code. But if you are reading this Nim tutorial, the chances are that you already know about Nim.\\nThe tutorial is available both online and as a PDF.\\nThis is a work-in-progress: if you spot any errors and/or you have an idea how to make this tutorial better, please report it to the issue tracker.\\nWho is this for?\\nPeople with no or minimal previous programming experience\\nPeople with some programming experience in other programming languages\\nPeople who want to explore Nim for the first time, starting from scratch\\nWho is this not for?\\nPeople with lots of programming experience: other, more advanced, tutorials might suit you better. See Official Tutorial or Nim by Example.\\nPeople experienced in Nim (feel free to help make this tutorial better)", "How to use this tutorial?\\n\\nThe aim of this tutorial is to give you the basics of programming and the Nim syntax so you can have an easier time following other tutorials and/or explore further by yourself.\\nInstead of just reading what is written, it would be the best if you try the stuff by yourself, modify the examples, think of some examples of your own, and be curious in general. The exercises at the end of some chapters should be non-negotiable — don’t skip them.\\nIf you need additional help understanding some parts of the tutorial or with the exercises, you can always ask for help on the Nim forum, the Nim Gitter channel, their Discord server, or Nim’s IRC channel on freenode, #nim.\\n"], "progress":0 },
  {"order": 1,"title":"Installation","texts": ["Nim has ready made distributions for all three major operating systems and there are several options when it comes to installing Nim.\\n\\nYou can follow the official installation procedure to install the latest stable version, or you can use a tool called choosenim which enables you to easily switch between thestableandthelatestdevelopmentversionifyou’reinterested in the latest features and bugfixes.\\n\\nWhichever way you choose, just follow the installation procedure explained at each link and Nim should be installed. We will check that the installation went well in a coming chapter.\\n\\nIf you’re using Linux, there is a high probability that your distribution has Nim in the package manager. If you are installing it that way, make sure it’s the most recent version (see the website for what is the latestversion), otherwise install via one of two methods mentioned above.\\n\\nIn this tutorial we will use the stable version. Originally, this tutorial was written for Nim 0.19 (released in September 2018), and it should work for any newer version, including Nim 1.0.\\n", "You can write Nim code in any text editor, and then compile and run it from the terminal. If you want syntax highlighting and code completion there are plugins for popular code editors which provide these features.\\n\\nMost of Nim users prefer the VS Code editor, with the Nim extension which provides syntax highlighting and code completion, and the Code Runner extension for quick compiling and running.\\n\\nThe author personally uses NeoVim editor, with this plugin which provides additional features like syntax highlighting and code completion.\\n\\nIf you’re using other code editors, see the wiki for available editor support.\\n", "\\n\\nTo check if the installation was successful, we will write a program which is traditionally used as an introductory example: Hello World.\\n\\nPrinting (as in: displaying on the screen; not on a paper with a printer) the phrase Hello World! in Nim is straightforward and it doesn’t require any boilerplate code.\\n\\nIn a new text file called e.g. helloworld.nim we need to write just one line of code:\\nhelloworld.nim\\n\\necho \"Hello World!\"", "First we need to compile our program, and then run it to see if it works as expected.\\n\\nOpen your terminal in the same directory where your file is (on Linux you can get 'Open Terminal here' if you right-click the directory in your file manager, on Windows you should use Shift + right-click to getthemenuoptionfor opening the command line).\\n\\nWe compile our program by typing in the terminal:\\n\\nnim c helloworld.nim\\n\\nAfter a successful compilation, we can run our program. On Linux we can run our program by typing ./helloworld in the terminal, and on Windows we do it by typing helloworld.exe.", "There is also a possibility to both compile and run the program with just one command. We need to type:\\n\\nnim c -r helloworld.nim\\n\\nc is telling Nim to compile the file, and -r is telling it to run it immediately.\\nTo see all compiler options, type nim --help in your terminal.\\n\\nIf you’re using VSCode with the Code Runner extension mentioned before, you’ll just have to press Ctrl+Alt+N and your file will be compiled and run.\\n\\nWhichever way you chose to run your program, after a brief moment in the output window (or in your terminal) you should see:\\n\\nHello World!\\n\\nCongratulations, you have successfully run your first Nim program!\\n\\nNow you know how to print some stuff on the screen (using the echo command), compile your program (typing nim c programName.nim in your terminal), and run it (various possibilities).\\nWe can now start to explore the basic elements which will help us to write simple Nim programs."], "progress":0 },
  {"order": 2,"title":"Naming values","texts": ["It is often helpful to give the values in our programs names to help us keep track of things. If we ask a user for his/her name, we want to store it for the later usage, without asking for it again and again every time we need to do some computation with it.\\n\\nIn the example pi = 3.14, the name pi is connected to the value 3.14. From our experience, we can tell that the type of a variable pi is a (decimal) number.\\n\\nAnother example would be firstName = Alice, where firstName is the name of a variable with the value Alice. We would say that the type of this variable is a word.\\n\\nIn programming languages this works similarly. These name assignments have their name, the value, and a type.", "Variable declaration\\n\\nNim is a statically typed programming language, meaning that the type of an assignment needs to be declared before using the value.\\n\\nIn Nim we also distinguish values that can change, or mutate, from those that can’t, but more on this later. We can declare a variable (a mutable assignment) using the var keyword, just by stating its name and type(thevaluecan be added later) by using this syntax:\\n\\nvar <name>: <type>\\n\\nIf we already know its value, we can declare a variable and give it a value immediately:\\n\\nvar <name>: <type> = <value>\\n\\n\\tAngular brackets(<>) are used to show something you can change.\\nSo <name> is not literally the word name in angular brackets but rather any name.\\n\\nNim also has type inference ability: the compiler can automatically detect the type of a name assignment from its value, without explicitly stating the type. We’ll look more into the various types in the next chapter.\\n\\nSo we can assign a variable without an explicit type like this:\\nvar <name> = <value>", "An example of this in Nim looks like this:\\n\\nvar a: int  \\nvar b = 7   \\n\\n\\tVariable a is of type int (integer) with no value explicitly set.\\n\\tVariable b has a value of 7. Its type is automatically detected as an integer.\\n\\nWhen assigning names it is important to choose names that mean something for your program. Simply naming them a, b, c, and so forth will quickly become confusing. It is not possible to use spaces in a name, as thatwouldsplitit into two. So if the name you choose consists of more than one word the usual way is to write it in camelCase style (notice that the first letter in a name should be lowercase).\\n\\nNote however that Nim is both case- and underscore-insensitive meaning that helloWorld and hello_world would be the same name. The exception to this is the first character, which is case-sensitive. Names can also include both numbers and other UTF-8 characters, even emojis should you wish that, but keep in mind you and possibly others will have to type them.", "Instead of typing var for each variable, multiple variables (not necessarily of the same type) can be declared in the same var block. In Nim, blocks are parts of code with the same indentation (same number of spaces before the first character), and the default indentation level is two spaces. You will see such blocks everywhere in a Nim program, not only for assigning names.\\n\\nvar\\n  c = -11\\n  d = \"Hello\"\\n  e = '!'\\n\\n\\tIn Nim tabs are not allowed as indentation.\\nYou can set up your code editor to convert pressing Tab to any number of spaces.\\nIn VS Code, the default setting is to convert Tab to four spaces. This is easily overridden in settings (Ctrl+,) by setting \"editor.tabSize\": 2.\\n\\nAs previously mentioned variables are mutable, i.e. their value can change (multiple times), but their type must stay the same as declared.\\n\\nvar f = 7\\n\\nf = -3\\nf = 19\\nf = \"Hello\" # error  \\n\\nVariable f has an initial value of 7 and its type is inferred as int.\\n\\tThe value of f is first changed to -3, and then to 19. Both of these are integers, the same as the original value.\\n\\tTrying to change the value of f to \"Hello\" produces an error because Hello is not a number, and this would change the type of f from an integer to a string.\\n\\t# error is a comment. Comments in Nim code are written after a # character. Everything after it on the same line will be ignored.", "Immutable assignment\\n\\nUnlike variables declared with var keyword, two more types of assignment exist in Nim, whose value cannot change, one declared with the const keyword, and the other declared with the let keyword.\\nConst\\n\\nThe value of an immutable assignment declared with const keyword must be known at compile time (before the program is run).\\n\\nFor example, we can declare the acceleration of gravity as const g = 9.81 or pi as const pi = 3.14, as we know their values in advance and these values will not change during the execution of our program.", "const g = 35\\ng = -27\\t# error \\n\\nvar h = -5\\nconst i = h + 7 # error \\n\\n\\tThe value of a constant cannot be changed.\\n\\tVariable h is not evaluated at compile time (it is a variable and its value can change during the execution of a program), consequently the value of constant i can’t be known at compile time, and this willraiseanerror.\\n\\nIn some programming languages it is a common practice to have the names of constants written in ALL_CAPS. Constants in Nim are written just like any other variable.", "Let\\n\\nImmutable assignments declared with let don’t need to be known at compile time, their value can be set at any time during the execution of a program, but once it is set, their value cannot change.\\n\\nlet j = 35\\nj = -27 # error \\n\\nvar k = -5\\nlet l = k + 7   \\n\\n\\tThe value of an immutable cannot be changed.\\n\\tIn contrast to const example above, this works.\\n\\nIn practice, you will see/use let more frequently than const.\\n\\nWhile you could use var for everything, your default choice should be let. Use var only for the variables which will be modified."], "progress":0 },
  {"order": 3,"title": "Basic data types","texts": ["Integers\\n\\nAs seen in the previous chapter, integers are numbers which are written without a fractional component and without a decimal point.\\n\\nFor example: 32, -174, 0, 10_000_000 are all integers. Notice that we can use _ as a thousands separator, to make larger numbers more readable (it is easier to see that we’re talking about 10 million when it’s written as 10_000_000 rather than as 10000000).\\n\\nThe usual mathematical operators — addition (+), subtraction (-), multiplication (*), and division (/) — work as one would expect. The first three operations always produce integers, while dividing two integers always gives a floating point number (a number with a decimal point) as a result, even if two numbers can be divided without a remainder.\\n\\nInteger division (division where the fractional part is discarded) can be achieved with the div operator. An operator mod is used if one is interested in the remainder (modulus) of an integer division. The result of these two operations is always an integer.", "let\\n  a = 11\\n  b = 4\\n\\necho \"a + b = \", a + b \\necho \"a - b = \", a - b\\necho \"a * b = \", a * b\\necho \"a / b = \", a / b\\necho\"a div b = \", a div b\\necho \"a mod b = \", a mod b\\n\\n\\tThe echo command will print to the screen everything that follows itseparated by commas. In this case, it first prints the string a + b = , and then after it, in the same row, it prints the result of the expression a + b.\\n\\nWe can compile and run the above code, and the output should be:\\n\\na + b = 15\\na - b = 7\\na * b = 44\\na / b=2.75\\na div b = 2a mod b = 3", "Floats\\n\\nFloating-point numbers, or floats for short, are an approximate representation of real numbers.\\n\\nFor example: 2.73,-3.14, 5.0, 4e7 are floats. Notice that we can use scientific notation for large floats, where the number after the e is the exponent. In this example, 4e7 is a notation representing 4 * 10^7.\\n\\nWe can also use the four basic mathematical operations between two floats. Operators div and mod are not defined for floats.", "let\\n  c = 6.75\\n  d = 2.25\\n\\necho \"c + d = \", c + d\\necho \"c - d = \", c - d\\necho \"c * d = \", c * d\\necho \"c / d = \", c / d\\n\\nc + d = 9.0  \\nc - d = 4.5\\nc * d = 15.1875\\nc / d = 3.0  \\n\\n\\tNotice that in the addition and division examples, even though we get a number without a decimal part, the result is still of the floating type.\\n\\nThe precedence of mathematical operations is as one would expect: multiplication and division have higher priority than addition and subtraction.\\n\\necho 2 + 3 * 4\\t#14\\necho 24 - 8 / 4\\t#22.0", "Converting floats and integers\\n\\nMathematical operations between variables of different numerical types are not possible in Nim, and they will produce an error:\\n\\nlet\\n  e = 5\\n  f = 23.456\\n\\necho e + f\\t# error\\n\\nThe values of variables need to be converted to the same type. Conversion is straight-forward: to convert to an integer, we use the int function, and to convert to a float the float function is used.", "let\\n  e = 5\\n  f = 23.987\\n\\necho float(e)\\t#5.0\\necho int(f)\\t#23\\n\\necho float(e) + f\\t#28.987\\necho e + int(f)    \\t#28\\n\\n\\tPrinting a float version of an integer e. (e remains of integer type)\\n\\tPrinting an int version of a float f.\\n\\tBoth operands are floats and can be added.\\n\\tBoth operands are integers and can be added.\\n\\nWhen using the int function to convert a float to an integer no rounding will be performed. The number simply drops any decimals. To perform rounding we must call another function, but for that we must know a bit more about how to use Nim.", "Characters\\n\\nThe char type is used for representing a single ASCII character.\\n\\nChars are written between two single ticks ('). Chars can be letters, symbols, or single digits. Multiple digits or multiple letters produce an error.\\n\\nlet\\n  h = 'z'\\n  i = '+'\\n  j = '2'\\n  k = '35' # error\\n  l = 'xy' # error", "Strings\\n\\nStrings can be described as a series of characters. Their content is written between two double quotes (\").\\n\\nWe might think of strings as words, but they can contain more than one word, some symbols, or digits.\\n\\nlet\\n  m = \"word\"\\n  n = \"A sentence with interpunction.\"\\n  o = \"\"\\n  p = \"32\"  \\n  q = \"!\"\\n\\n\\tAn empty string.\\n\\tThis is not a number (int). It is inside double quotes, making it a string.\\n\\tEven though this is only one character, it is not a char because it is enclosed inside of double quotes.", "Special characters\\n\\nIf we try to print the following string:\n\necho \"some\\ nim\\ tips\"\\n\\nthe result might surprise us:\\n\\nsome\\nim\\tips\\n\\nThis is because there are several characters which have a special meaning. They are used by prepending the escape character \\ to them.\\n\\n\\t\\ n is a newline character\\n\\n\\t\\ t is a tab character\\n\\n\\t\\ \\ is a backslash (since one \\ is used as the escape character)\\n\\nIf we wanted to print the above example as it was written, we have two possibilities:", "Use \\ \\ instead of \\ to print backslashes, or\\n\\n\\tUse raw strings which have syntax r\"…\" (putting a letter r immediately before the first quote), in which there are no escape characters and no special meanings: everything is printed as it is.\\n\\necho \"some\\ nim\\ tips\"\\necho r\"some\\ nim\\ tips\"\\n\\nsome\\ nim\\ tips\\nsome\\ nim\\ tips\\n\\nThere are more special characters than the ones listed above, and they are all found in the Nim manual.", "String concatenation\\n\\nStrings in Nim are mutable, meaning their content can change. With the add function we can add (append) either another string or a char to an existing string. If we don’t want to change the original string, we can also concatenate (join together) strings with the & operator, this returns a new string.\\n\\nvar\\n  p = \"abc\"\\n  q = \"xy\"\\n  r = 'z'\\n\\np.add(\"def\")\\necho \"p is now: \", p\\t#p is now: abcdef\\n\\nq.add(r)\\necho \"q is now: \", q\\t#q is now: xyz\\n\\necho \"concat: \", p & q\\t#concat: abcdefxyz\\n\\necho \"p is still: \", p\\t#p is still: abcdef\\necho \"q is still: \", q\\t#q is still: xyz", "If we plan to modify strings, they should be declared as var.\\n\\tAdding another string modifies the existing string p in-place, changing its value.\\n\\tWe can also add a char to a string.\\n\\tConcatenating two strings produces a new string, without modifying the original strings.", "Boolean\\n\\nA boolean (or just bool) data type can only have two values: true or false. Booleans are usually used for control flow (see next chapter), and they are often a result of relational operators.\\n\\nThe usual naming convention for boolean variables is to write them as a simple yes/no (true/false) questions, e.g. isEmpty, isFinished, isMoving, etc.", "Relational operators\\n\\nRelational operators test the relation between two entities, which must be comparable.\\n\\nTo compare if two values are the same, == (two equal signs) is used. Do not confuse this with =, which is used for assignment as we saw earlier.\\n\\nHere are all the relational operators defined for integers:\\n\\nlet\\n  g = 31\\n  h = 99\\n\\necho \"g is greater than h: \", g > h\\t#false\\necho \"g is smaller than h: \", g < h\\t#true\\necho \"g is equal to h: \", g == h\\t#false\\necho \"g is not equal to h: \", g != h\\t#true\\necho \"g is greater or equal to h: \", g >= h\\t#false\\necho \"g is smaller or equal to h: \", g <= h\\t#true", "We can also compare characters and strings:\\n\\nlet\\n  i = 'a'\\n  j = 'd'\\n  k = 'Z'\\n\\necho i < j\\t#true\\necho i < k\\t#false\\n\\nlet\\n  m = \"axyb\"\\n  n = \"axyz\"\\n  o = \"ba\"\\n  p = \"ba \"\\n\\necho m < n\\t#true\\necho n < o\\t#true\\necho o < p\\t#true", "All uppercase letters come before lowercase letters.\\n\\tString comparison works char-by-char. First three characters are the same, and character b is smaller than character z.\\n\\tString length doesn’t matter for comparison if their characters are not identical.\\n\\tShorter string is smaller than the longer one.", "Logical operators\\n\\nLogical operators are used to test the truthiness of an expression consisting of one or more boolean values.\\n\\n\\tLogical and returns true only if both members are true\\n\\n\\tLogical or returns true if there is at least one member which is true\\n\\n\\tLogical xor returns true if one member is true, but the other is not\\n\\n\\tLogical not negates the truthiness of its member: changing true to false, and vice versa (it is the only logical operator that takes just one operand)", "Recap\\n\\nThis was the longest chapter in this tutorial and we covered a lot of ground. Take your time to go trough each data type and experiment with what you can do with each of them.\\n\\nTypes might seem like a restriction at first, but they allow the Nim compiler to both make your code faster, and make sure you’re not doing something wrong by accident — this is especially beneficial in large code bases.\\n\\nNow you know the basic data types and several operations on them, which should be enough to do some simple calculations in Nim. Test your knowledge by doing the following exercises."],"exercises": [{"exercise":"What type should it be?\\n\\nvar someVariableName : ______ = 's'\\n\\n\\n\\na:\\tint\\nb:\\tchar\\nc:\\tstring\\nd:\\tnone","type":"radio","answer":"b"},{"exercise":"How do you comment a line in Nim?\\n\\n\\n\\na:\\t//\\nb:\\t/* */\\nc:\\t/** */\\nd:\\t#","type":"radio","answer":"d"},{"exercise":"How do you print something on the screen?\\n\\n\\n\\na:\\tprint \"something\"\\nb:\\techo \"something\"\\nc:\\tprint (\"something\")\\nd:\\techo 'something'","type":"radio","answer":"b"},{"exercise":"How can you convert an integer(5) to float?","type":"text","answer":"float(5)"}], "progress" : 0},
  {"order": 4,"title":"Control flow","texts": ["So far in our programs every line of code was executed at some point. Control flow statements allow us to have parts of code which will be executed only if some boolean condition is satisfied.\\n\\nIf we think of our program as a road we can think of control flow as various branches, and we pick our path depending on some condition. For example, we will buy eggs only if their price is less than some value. Or, if it is raining, we will bring an umbrella, otherwise (else) we will bring sunglasses.\\n\\nWritten in pseudocode, these two examples would look like this:\\n\\nif eggPrice < wantedPrice:\\n  buyEggs\\n\\nif isRaining:\\n  bring umbrella\\nelse:\\n  bring sunglasses\\n\\nNim syntax is very similar, as you’ll see below.", "If statement\\n\\nAn if statement as shown above is the simplest way to branch our program.\\n\\nThe Nim syntax for writing if statement is:\\n\\nif <condition>:\\n  <indented block>  \\n\\n\\tThe condition must be of boolean type: either a boolean variable or a relational and/or logical expression.\\n\\tAll lines following the if line which are indented two spaces make the same block and will be executed only if the condition is true.", "If statements can be nested, i.e. inside one if-block there can be another if statement.\\n\\nlet\\n  a = 11\\n  b = 22\\n  c = 999\\n\\nif a < b:\\t#true\\n  echo \"a is smaller than b\"\\n  if 10*a < b:  \\t#false\\n    echo \"not only that, a is *much* smaller than b\"\\n\\nif b < c:\\t#true\\n  echo \"b is smaller than c\"\\n  if 10*b < c:\\t#true\\n    echo \"not only that, b is *much* smaller than c\"\\n\\nif a+b > c:\\t#false\\n  echo \"a and b are larger than c\"\\n  if 1 < 100 and 321 > 123:  \\n    echo \"did you know that 1 is smaller than 100?\"\\n    echo \"and 321 is larger than 123! wow!\"", "The first condition is true, the second is false — inner echo is not executed.\\n\\tBoth conditions are true and both lines are printed.\\n\\tThe first condition is false — all lines inside of its block will be skipped, nothing is printed.\\n\\tUsing the logical and inside of the if statement.", "Else\\n\\nElse follows after an if-block and allows us to have a branch of code which will be executed when the condition in the if statement is not true.\\n\\nlet\\n  d = 63\\n  e = 2.718\\n\\nif d < 10:\\t#false\\n  echo \"d is a small number\"\\nelse:\\t#true\\n  echo \"d is a large number\"\\n\\nif e < 10:\\t#true\\n  echo \"e is a small number\"\\nelse:\\t#false\\n  echo \"e is a large number\"\\n\\n\\tIf you only want to execute a block if the statement is false, you can simply negate the condition with the not operator.", "Elif\\n\\nElif is short for \"else if\", and enables us to chain multiple if statements together.\\n\\nThe program tests every statement until it finds one which is true. After that, all further statements are ignored.\\n\\nlet\\n  f = 3456\\n  g = 7\\n\\nif f < 10:\\t#false\\n  echo \"f is smaller than 10\"\\nelif f < 100:\\t#false\\n  echo \"f is between 10 and 100\"\\nelif f < 1000:\\t#false\\n  echo \"f is between 100 and 1000\"\\nelse:\\t#true\\n  echo \"f is larger than 1000\"", "if g < 1000:\\t#true\\n  echo \"g is smaller than 1000\"\\nelif g < 100:\\t#ignored\\n  echo \"g is smaller than 100\"\\nelif g < 10:\\t#ignored\\n  echo \"g is smaller than 10\"\\n\\n\\tIn the case of g, even though g satisfies all three conditions, only the first branch is executed, automatically skipping all the other branches.", "Case\\n\\nA case statement is another way to only choose one of multiple possible paths, similar to the if statement with multiple elifs. A case statement, however, doesn’t take multiple boolean conditions, but rather any value with distinct states and a path for each possible value.\\n\\nCode written with in if-elif block looking like this:\\n\\nif x == 5:\\n  echo \"Five!\"\\nelif x == 7:\\n  echo \"Seven!\"\\nelif x == 10:\\n  echo \"Ten!\"\\nelse:\\n  echo \"unknown number\"", "It can be written with case statement like this:\\n\\ncase x\\nof 5:\\n  echo \"Five!\"\\nof 7:\\n  echo \"Seven!\"\\nof 10:\\n  echo \"Ten!\"\\nelse:\\n  echo \"unknown number\"", "Unlike the if statement, case statement must cover all possible cases. If one is not interested in some of those cases, else: discard can be used.\\n\\nlet h = 'y'\\ncase h\\nof 'x':\\n  echo \"You've chosen x\"\\nof 'y':\\n  echo \"You've chosen y\"\\t#true\\nof 'z':\\n  echo \"You've chosen z\"\\nelse: discard  \\n\\n\\tEven though we are interested in only three values of h, we must include this line to cover all other possible cases (all other characters). Without it, the code would not compile.", "We can also use multiple values for each branch if the same action should happen for more than one value.\\n\\nlet i = 7\\n\\ncase i\\n  of 0:\\n    echo \"i is zero\"\\n  of 1, 3, 5, 7, 9:\\n    echo \"i is odd\"\\true\\n  of 2, 4, 6, 8:\\n    echo \"i is even\"\\n  else:\\n    echo \"i is too large\""],"exercises": [{"exercise":"What  will be printed?\\n\\nvar y = \"sad\"\\nvar y = 12\\ncase $(y-1)\\nof $12 & \"-1\":\\n  echo \"first\"\\nof $11:\\n  echo \"second\"\\nof \"(y-1)\":\\n  echo \"third\"\\nelse:\\n  echo \"none\"","type":"text","answer":"second"},{"exercise":"What will the following code snippet do?\\n\\nlet n = 22\\nif n > 30:\\necho \"n is greater than 30\"\\nelse:\\n  echo \"22 is less than 30\"\\n\\n\\n\\na:\\techo \"n is greater than 30\"\\nb:\\techo \"22 is less than 30\"\\nc:\\tdoes not compile\\nd:\\techo \"n is less than 30\"","type":"radio","answer":"c"},{"exercise":"Insert the missing word\\n\\nif n > 30:\\n  echo \"n is greater than 30\"\\n____ n < 30:\\n  echo \"n is less than 30\\\n else:\\n  echo \"n is equal to 30\"","type":"text","answer":"elif"},{"exercise":"What does a discard statment do?\\n\\n\\n\\na:\\tcovers all cases\\nb:\\tdeletes the variable that was given to the case\\nc:\\tremoves the whole case statement\\nd:\\tnothing","type":"radio","answer":"a"}], "progress":0 },
  {"order": 5,"title":"Loops","texts": ["Loops are another control flow construct which allow us to run some parts of code multiple times.\\n\\nIn this chapter we will meet two kinds of loops:\\n\\n\\tfor-loop: run a known number of times\\n\\n\\twhile-loop: run as long some condition is satisfied", "For loop\\n\\nSyntax of a for-loop is:\\n\\nfor <loopVariable> in <iterable>:\\n  <loop body>\\n\\nTraditionally, i is often used as a loopVariable name, but any other name can be used. That variable will be available only inside the loop. Once the loop has finished, the value of the variable is discarded.\\n\\nThe iterable is any object we can iterate through. Of the types already mentioned, strings are iterable objects. (More iterable types will be introduced in the next chapter.)\\n\\nAll lines in the loop body are executed at every loop, which allows us to efficiently write repeating parts of code.", "If we want to iterate through a range of (integer) numbers in Nim, the syntax for the iterable is start .. finish where start and finish are numbers. This will iterate through all the numbers between start and finish, including both start and finish. For the default range iterable, start needs to be smaller than finish.\\n\\nIf we want to iterate until a number (not including it), we can use ..<:\\n\\nfor n in 5 .. 9:\\n  echo n\\t#5 6 7 8 9\\n\\necho \"\"\\n\\nfor n in 5 ..< 9: \\n  echo n\\t#5 6 7 8\\n\\n\\tIterating through a range of numbers using .. — both ends are included in the range.\\n\\tIterating through the same range using ..< — it iterates until the higher end, not including it.", "If we want to iterate through a range of numbers with a step size different than one, countup is used. With countup we define the starting value, the stopping value (included in the range), and the step size.\\n\\nfor n in countup(0, 16, 4):\\n  echo n\\t#0 4 8 12 16\\n\\n\\tCounting up from zero to 16, with a step size of 4. The end (16) is included in the range.\\n\\nTo iterate through a range of numbers where the start is larger than finish, a similar function called countdown is used. Even if we’re counting down, the step size must be positive.", "for n in countdown(4, 0):\\n  echo n\\t#4 3 2 1 0\\n\\nfor n in countdown(-3, -9, 2):\\n  echo n\\t#-3 -5 -7 -9\\n\\n\\tTo iterate from a higher to a lower number, we must use countdown (The .. operator can only be used when the starting value is smaller than the end value).\\n\\tEven when counting down, the step size must be a positive number.\\n\\nSince string is an iterable, we can use a for-loop to iterate through each character of the string (this kind of iteration is sometimes called a for-each loop).\\n\\nlet word = \"alphabet\"\\n\\nfor letter in word:\\n  echo letter\\n\\na\\nl\\np\\nh\\na...", "If we also need to have an iteration counter (starting from zero), we can achieve that by using for <counterVariable>, <loopVariable> in <iterator>: syntax. This is very practical if you want to iterate through one iterable, and simultaneously access another iterable at the same offset.\\n\\nfor i, letter in word:\\n  echo \"letter \", i, \" is: \", letter\\n\\nletter 0 is: a\\nletter 1 is: l\\nletter 2 is: p\\nletter 3 is: h\\nletter 4 is: a\\nletter 5 is: b\\nletter 6 is: e\\nletter 7 is: t", "While loop\\n\\nWhile loops are similar to if statements, but they keep executing their block of code as long as the condition remains true. They are used when we don’t know in advance how many times the loop will run.\\n\\nWe must make sure the loop will terminate at some point and not become an infinite loop.\\n\\nvar a = 1\\n\\nwhile a*a < 10:\\n  echo \"a is: \", a\\n  inc a\\n\\necho \"final value of a: \", a\\n\\n\\tThis condition will be checked every time before entering the new loop and executing the code inside of it.inc is used to increment a by one. It is the same as writing a = a + 1 or a += 1.\\n\\na is: 1\\na is: 2\\na is: 3\\nfinal value of a: 4", "Break and continue\\n\\nThe break statement is used to prematurely exit from a loop, usually if some condition is met.\\n\\nIn the next example, if there were no if statement with break in it, the loop would continue to run and print until i becomes 1000. With the break statement, when i becomes 3, we immediately exit the loop (before printing the value of i).\\n\\nvar i = 1\\n\\nwhile i < 1000:\\n  if i == 3:\\n    break\\n  echo i\\t#1 2\\n  inc i", "The continue statement starts the next iteration of a loop immediately, without executing the remaining lines of the current iteration. Notice how 3 and 6 are missing from the output of the following code:\\n\\nfor i in 1 .. 8:\\n  if (i == 3) or (i == 6):\\n    continue\\n  echo i\\n\\n1\\n2\\n4\\n5\\n7\\n8"],"exercises": [{"exercise":"The countup/countdown processes' third paramater is ____ ____","type":"text","answer":"step size"}, {"exercise":"continue statement...\\n\\n\\n\\na:\\tskips the remaining iterations\\nb:starts the next iteration\\t\\nc:\\tstarts the last iteration\\nd:\\texits from the loop","type":"radio","answer":"b"}], "progress":0 },
  {"order": 6,"title":"Containers","texts": ["Containers are data types which contain a collection of items and allow us to access those elements. Typically a container is also iterable, meaning that we can use them the same way we used strings in the loops chapter.\\n\\nFor example, a grocery list is a container of items we want to buy, and a list of primes is a container of numbers. Written in pseudocode:\\n\\ngroceryList = [ham, eggs, bread, apples]\\nprimes = [1, 2, 3, 5, 7]", "Arrays\\n\\nAn array is the simplest container type. Arrays are homogeneous, i.e. all elements in an array must have the same type. Arrays are also of a constant size, meaning that the amount of elements (or rather: the amount of possible elements), must be known at compile-time. This means that we call arrays a \"homogeneous container of a constant length\".\\n\\nThe array type is declared using array[<length>, <type>], where length is the total capacity of the array (number of elements it can fit), and type is a type of all its elements. The declaration can be omitted if both length and type can be inferred from the passed elements.\\n\\nThe elements of an array are enclosed inside of square brackets.", "var\\n  a: array[3, int] = [5, 7, 9]\\n  b = [5, 7, 9]\\n  c = []  # error\\n  d: array[7, string]\\n\\n\\tIf we provide the values, the length and type of array b are known at compile time. Although correct, there is no need to specifically declare it like array a. Neither the length nor the type of the elements can be inferred from this kind of declaration — this produces an error. The correct way to declare an empty array (which will be filled later) is to give its length and type, without providing the values of its elements — array d can contain seven strings.\\n\\nSince the length of an array has to be known at compile-time, this will not work:\\n\\nconst m = 3\\nlet n = 5\\nvar a: array[m, char]\\nvar b: array[n, char] # error \\n\\n\\tThis produces an error because n is declared using let — its value is not known at compile time. We can only use values declared with const as a length parameter for an array initialization.", "Sequences\\n\\nSequences are containers similar to arrays, but their length doesn’t have to be known at compile time, and it can change during runtime: we declare only the type of the contained elements with seq[<type>]. Sequences are also homogeneous, i.e. every element in a sequence has to be the same type.\\n\\nThe elements of a sequence are enclosed between @[ and ].\\n\\nvar\\n  e1: seq[int] = @[]   \\n  f = @[\"abc\", \"def\"]\\n\\n\\tThe type of an empty sequence must be declared.\\n\\tThe type of a non-empty sequence can be inferred. In this case, it is a sequence containing strings.", "Another way to initialize an empty sequence is to call the newSeq procedure. We’ll look more at procedure calls in the next chapter but for now just know that this is also a possibility:\\n\\nvar\\n  e = newSeq[int]() \\n\\n\\tProviding the type parameter inside of square brackets allows the procedure to know that it shall return a sequence of a certain type.\\nA frequent error is omission of the final (), which must be included.\\n\\nWe can add new elements to a sequence with the add function, similar to how we did with strings. For this to work the sequence must be mutable (defined with var), and the element we’re adding must be of the same type as the elements in the sequence.", "var\\n  g = @['x', 'y']\\n  h = @['1', '2', '3']\\n\\ng.add('z')\\necho g\\n\\nh.add(g)\\necho h\\n\\n\\tAdding a new element of the same type (char).\\n\\tAdding another sequence containing the same type.\\n\\n@['x', 'y', 'z']\\n@['1', '2', '3', 'x', 'y', 'z']\\n\\nTrying to pass different types to the existing sequences will produce an error:\\n\\nvar i = @[9, 8, 7]\\n\\ni.add(9.81)\\t# error \\ng.add(i)\\t\\t# error\\n\\n\\tTrying to add a float to a sequence of int.\\n\\tTrying to add a sequence of int to a sequence of char.", "Since sequences can vary in length we need a way to get their length, for this we can use the len function.\\n\\nvar i = @[9, 8, 7]\\necho i.len\\n\\ni.add(6)\\necho i.len\\n\\n3\\n4", "Indexing and slicing\\n\\nIndexing allows us to get a specific element from a container by its index. Think of the index as a position inside of the container.\\n\\nNim, like many other programming languages, has zero-based indexing, meaning that the first element in a container has the index zero, the second element has the index one, etc.\\n\\nIf we want to index \"from the back\", it is done by using the ^ prefix. The last element (first from the back) has index ^1.\\n\\nThe syntax for indexing is <container>[<index>]." ,"let j = ['a', 'b', 'c', 'd', 'e']\\n\\necho j[1]\\necho j[^1]\\n\\n\\tZero-based indexing: the element at index 1 is b.\\n\\tGetting the last element.\\n\\nb\\ne\\n\\nSlicing allows us to get a series of elements with one call. It uses the same syntax as ranges (introduced in the for loop section).\\n\\nIf we use start .. stop syntax, both ends are included in the slice. Using start ..< stop syntax, the stop index is not included in the slice.", "The syntax for slicing is <container>[<start> .. <stop>].\\n\\necho j[0 .. 3]\\necho j[0 ..< 3]\\n\\n@[a, b, c, d]\\n@[a, b, c]\\n\\nBoth indexing and slicing can be used to assign new values to the existing mutable containers and strings.", "var\\n  k: array[5, int]\\n  l = @['p', 'w', 'r']\\n  m = \"Tom and Jerry\"\\n\\nfor i in 0 .. 4:  \\n  k[i] = 7 * i\\necho k\\n\\nl[1] = 'q'\\necho l\\n\\nm[8 .. 9] = \"Ba\"  \\necho m\\n\\n\\tArray of length 5 has indexes from zero to four. We will assign a value to each element of the array.\\n\\tAssigning (changing) the second element (index 1) of a sequence.\\n\\tChanging characters of a string at indexes 8 and 9.\\n\\n[0, 7, 14, 21, 28]\\n@['p', 'q', 'r']\\nTom and Barry", "Tuples\\n\\nBoth of the containers we’ve seen so far have been homogeneous. Tuples, on the other hand, contain heterogeneous data, i.e. elements of a tuple can be of different types. Similarly to arrays, tuples have fixed-size.\\n\\nThe elements of a tuple are enclosed inside of parentheses.\\n\\nlet n = (\"Banana\", 2, 'c')\\necho n\\n\\n\\tTuples can contain fields of different types. In this case: string, int, and char.\\n\\n(Field0: \"Banana\", Field1: 2, Field2: 'c')", "We can also name each field in a tuple to distinguish them. This can be used for accessing the elements of the tuple, instead of indexing.\\n\\nvar o = (name: \"Banana\", weight: 2, rating: 'c')\\n\\no[1] = 7\\no.name = \"Apple\"\\necho o\\n\\n\\tChanging the value of a field by using the field’s index.\\n\\tChanging the value of a field by using the field’s name.\\n\\n(name: \"Apple\", weight: 7, rating: 'c')"],"exercises": [{"exercise":"What characters enclose sequences?(3 chars without spaces)","type":"text","answer":"@[]"}, {"exercise":"How can you start indexing from the back? (1 character)","type":"text","answer":"^"}, {"exercise":"What will be in ret?\\n\\nvar\\n  ret: string\\n  m = \"Batman\"\\n\\nfor i in 2 ..< 4:\\n  ret = ret & m[i]\\n\\n\\n\\na:\\tatm\\nb:\\tat\\nc:\\ttm\\nd:\\ttma","type":"radio","answer":"c"}], "progress":0 },
  {"order": 7,"title":"Procedures","texts": ["Procedures, or functions as they are called in some other programming languages, are parts of code that perform a specific task, packaged as a unit. The benefit of grouping code together like this is that we can call these procedures instead of writing all the code over again when we wish to use the procedure’s code.\\n\\nIn some of the previous chapters we’ve looked at the Collatz conjecture in various different scenarios. By wrapping up the Collatz conjecture logic into a procedure we could have called the same code for all the exercises.\\n\\nSo far we have used many built-in procedures, such as echo for printing, add for adding elements to a sequence, inc to increase the value of an integer, len to get the length of a container, etc. Now we’ll see how to create and use our own procedures.\\n\\nSome of the advantages of using procedures are:\\n\\tReducing code duplication\\n\\tEasier to read code as we can name pieces by what they do\\n\\tDecomposing a complex task into simpler steps\\n\\nAs mentioned in the beginning of this section, procedures are often called functions in other languages. This is actually a bit of a misnomer if we consider the mathematical definition of a function. Mathematical functions take a set of arguments (like f(x, y), where f is a function, and x and y are its arguments) and always return the same answer for the same input.\\n\\nProgrammatic procedures on the other hand don’t always return the same output for a given input. Sometimes they don’t return anything at all. This is because our computer programs can store state in the variables we mentioned earlier which procedures can read and change. In Nim, the word func is currently reserved to be used as the more mathematically correct kind of function, forcing no side-effects.", "Declaring a procedure\\n\\nBefore we can use (call) our procedure, we need to create it and define what it does.\\n\\nA procedure is declared by using the proc keyword and the procedure name, followed by the input parameters and their type inside of parentheses, and the last part is a colon and the type of the value returned from a procedure, like this:\\n\\nproc <name>(<p1>: <type1>, <p2>: <type2>, ...): <returnType>\\n\\nThe body of a procedure is written in the indented block following the declaration appended with a = sign.\\n\\nproc findMax(x: int, y: int): int =\\n  if x > y:\\n    return x\\n  else:\\n    return y\\n  # this is inside of the procedure\\n# this is outside of the procedure\\n\\n\\tDeclaring procedure called findMax, which has two parameters, x and y, and it returns an int type.\\n\\tTo return a value from a procedure, we use the return keyword.", "proc echoLanguageRating(language: string) =\\n  case language\\n  of \"Nim\", \"nim\", \"NIM\":\\n    echo language, \" is the best language!\"\\n  else:\\n    echo language, \" might be a second-best language.\"\\n\\n\\tThe echoLanguageRating procedure just echoes the given name, it doesn’t return anything, so the return type is not declared.\\n\\nNormally we’re not allowed to change any of the parameters we are given. Doing something like this will throw an error:\\n\\nproc changeArgument(argument: int) =\\n  argument += 5\\n\\nvar ourVariable = 10\\nchangeArgument(ourVariable)\\n\\nIn order for this to work we need to allow Nim, and the programmer using our procedure, to change the argument by declaring it as a variable:\\n\\nproc changeArgument(argument: var int) =\\n  argument += 5\\n\\nvar ourVariable = 10\\nchangeArgument(ourVariable)\\necho ourVariable\\nchangeArgument(ourVariable)\\necho ourVariable\\n\\n\\tNotice how argument is now declared as a var int and not just as an int.\\n\\n15\\n20", "This of course means that the name we pass it must be declared as a variable as well, passing in something assigned with const or let will throw an error.\\n\\nWhile it is good practice to pass things as arguments it is also possible to use names declared outside the procedure, both variables and constants:\\n\\nvar x = 100\\n\\nproc echoX() =\\n  echo x\\n  x += 1\\n\\nechoX()\\nechoX()\\n\\n\\tHere we access the outside variable x.\\n\\tWe can also update its value, since it’s declared as a variable.\\n\\n100\\n101", "Calling the procedures\\n\\nAfter we have declared a procedure, we can call it. The usual way of calling procedures/functions in many programming languages is to state its name and provide the arguments in the parentheses, like this:\\n\\n<procName>(<arg1>, <arg2>, ...)\\n\\nThe result from calling a procedure can be stored in a variable.\\n\\nIf we want to call our findMax procedure from the above example, and save the return value in a variable we can do that with:\\n\\nlet\\n  a = findMax(987, 789)\\n  b = findMax(123, 321)\\n  c = findMax(a, b)\\n\\necho a\\necho b\\necho c\\n\\n\\tThe result from the function findMax is here named c, and is called with the results of our first two calls (findMax(987, 321)).\\n\\n987\\n321\\n987", "Nim, unlike many other languages, also supports Uniform Function Call Syntax, which allows many different ways of calling procedures.\\n\\nThis one is a call where the first argument is written before the function name, and the rest of the parameters are stated in parentheses:\\n\\n<arg1>.<procName>(<arg2>, ...)\\n\\nWe have used this syntax when we were adding elements to an existing sequence (<seq>.add(<element>)), as this makes it more readable and expresses our intent more clearly than writing add(<seq>, <element>). We can also omit the parentheses around the arguments:\\n\\n<procName> <arg1>, <arg2>, ...\\n\\nWe’ve seen this style being used when we call the echo procedure, and when calling the len procedure without any arguments. These two can also be combined like this, but this syntax however is not seen very often:\\n\\n<arg1>.<procName> <arg2>, <arg3>, ...", "The uniform call syntax allows for more readable chaining of multiple procedures:\\n\\nproc plus(x, y: int): int =\\n  return x + y\\n\\nproc multi(x, y: int): int =\\n  return x * y\\n\\nlet\\n  a = 2\\n  b = 3\\n  c = 4\\n\\necho a.plus(b) == plus(a, b)\\necho c.multi(a) == multi(c, a)\\n\\necho a.plus(b).multi(c)\\necho c.multi(b).plus(a)\\n\\n\\tIf multiple parameters are of the same type, we can declare their type in this compact way.\\n\\tFirst we add a and b, then the result of that operation (2 + 3 = 5) is passed as the first parameter to the multi procedure, where it is multiplied by c (5 * 4 = 20).\\n\\tFirst we multiply c and b, then the result of that operation (4 * 3 = 12) is passed as the first parameter to the plus procedure, where it is added with a (12 + 2 = 14).\\n\\ntrue\\ntrue\\n20\\n14", "Result variable\\n\\nIn Nim, every procedure that returns a value has an implicitly declared and initialized (with a default value) result variable. The procedure will return the value of this result variable when it reaches the end of its indented block, even with no return statement.\\n\\nproc findBiggest(a: seq[int]): int =\\n  for number in a:\\n    if number > result:\\n      result = number\\n  # the end of proc\\n\\nlet d = @[3, -5, 11, 33, 7, -15]\\necho findBiggest(d)\\n\\n\\tThe return type is int. The result variable is initialized with the default value for int: 0.\\n\\tWhen the end of the procedure is reached, the value of result is returned.\\n\\n33", "Beware! In older Nim versions (before Nim 0.19.0), the default value of strings and sequences was nil, and when we would use them as returning types, the result variable would need to be initialized as an empty string (\"\") or as an empty sequence (@[]).\\n\\nproc keepOdds(a: seq[int]): seq[int] =\\n  # result = @[]\\n  for number in a:\\n    if number mod 2 == 1:\\n      result.add(number)\\n\\n\\nlet f = @[1, 6, 4, 43, 57, 34, 98]\\necho keepOdds(f)\\n\\n\\tIn Nim version 0.19.0 and newer, this line is not needed — sequences are automatically initialized as empty sequences.\\nIn older Nim versions, sequences must be initialized, and without this line the compiler would throw an error. (Notice that var must not be used, as result is already implicitly declared.)\\n\\n@[1, 43, 57]", "Inside of a procedure we can also call other procedures.\\n\\nproc isDivisibleBy3(x: int): bool =\\n  return x mod 3 == 0\\n\\nproc filterMultiplesOf3(a: seq[int]): seq[int] =\\n  # result = @[]\\n  for i in a:\\n    if i.isDivisibleBy3():\\n      result.add(i)\\n\\nlet\\n  g = @[2, 6, 5, 7, 9, 0, 5, 3]\\n  h = @[5, 4, 3, 2, 1]\\n  i = @[626, 45390, 3219, 4210, 4126]\\n\\necho filterMultiplesOf3(g)\\necho h.filterMultiplesOf3()\\necho filterMultiplesOf3 i\\n\\n\\tOnce again, this line is not needed in the newer versions of Nim.\\n\\tCalling the previously declared procedure. Its return type is bool and can be used in the if-statement.\\n\\tThe third way of calling a procedure, as we saw above.\\n\\n@[6, 9, 0, 3]\\n@[3]\\n@[45390, 3219]", "Forward declaration\\n\\nAs mentioned in the very beginning of this section we can declare a procedure without a code block. The reason for this is that we have to declare procedures before we can call them, doing this will not work:\\n\\necho 5.plus(10) # error\\n\\nproc plus(x, y: int): int =\\n  return x + y\\n\\n\\tThis will throw an error as plus isn’t defined yet.\\n\\tHere we define plus, but since it’s after we use it Nim doesn’t know about it yet.\\n\\nThe way to get around this is what’s called a forward declaration:\\n\\nproc plus(x, y: int): int\\n\\necho 5.plus(10)\\n\\nproc plus(x, y: int): int =\\n  return x + y\\n\\n\\tHere we tell Nim that it should consider the plus procedure to exist with this definition.\\n\\tNow we are free to use it in our code, this will work.\\n\\tThis is were plus is actually implemented, this must of course match our previous definition."],"exercises": [{"exercise":"What is the problem with the following snippet?var ret = 10\\n\\nfor i in 2 ..< 4:\\n  discard minus(ret, i)\\n\\nproc minus(a: int, b : int): int =\\n  return a - b\\n\\n\\n\\na:\\tforward declaration needed\\nb:\\tbad indentation\\nc:\\tret has no type\\nd:\\tdiscard will skip the whole procedure","type":"radio","answer":"a"}, {"exercise":"Declare a procedure called test, the arguments are a number n and a character c, there is no returning value","type":"text","answer":"proc test(n: int, v: char)"}], "progress":0 },
  {"order": 8,"title":"Modules","texts": ["So far we have used the functionality which is available by default every time we start a new Nim file. This can be extended with modules, which give more functionality for some specific topic.\\n\\nSome of the most used Nim modules are:\\n\\n\\tstrutils: additional functionality when dealing with strings\\n\\n\\tsequtils: additional functionality for sequences\\n\\n\\tmath: mathematical functions (logarithms, square roots, …​), trigonometry (sin, cos, …​)\\n\\n\\ttimes: measure and deal with time\\n\\nBut there are many more, both in what’s called the standard library and in the nimble package manager.", "Importing a module\\n\\nIf we want to import a module and all of its functionality, all we have to do is put import <moduleName> in our file. This is commonly done on the top of the file so we can easily see what our code uses.\\nimport strutils\\n\\nlet\\n  a = \"My string with whitespace.\"\\n  b = '!'\\n\\necho a.split()\\necho a.toUpperAscii()\\necho b.repeat(5)\\n\\n\\tImporting strutils.\\n\\tUsing split from strutils module. It splits the string in a sequence of words.\\n\\ttoUpperAscii converts all ASCII letters to uppercase.\\n\\trepeat is also from strutils module, and it repeats either a character or a whole string the requested amount of times.\\n\\n@[\"My\", \"string\", \"with\", \"whitespace.\"]\\nMY STRING WITH WHITESPACE.\\n!!!!!", "To the users coming from other programming languages (especially Python), the way that imports work in Nim might seem \"wrong\". If that’s the case, this is the recommended reading.", "import math\\n\\nlet\\n  c = 30.0 # degrees\\n  cRadians = c.degToRad()\\n\\necho cRadians\\necho sin(cRadians).round(2)\\n\\necho 2^5\\n\\n\\tImporting math.\\n\\tConverting degrees to radians with degToRad.\\n\\tsin takes radians. We round (also from math module) the result to at most 2 decimal places. (Otherwise the result would be: 0.4999999999999999)\\n\\tMath module also has ^ operator for calculating powers of a number.\\n\\n0.5235987755982988\\n0.5\\n32", "Creating our own\\n\\nOften times we have so much code in a project that it makes sense to split it into pieces that each does a certain thing. If you create two files side by side in a folder, let’s call them firstFile.nim and secondFile.nim, you can import one from the other as a module:\\n\\nproc plus*(a, b: int): int =\\n  return a + b\\n\\nproc minus(a, b: int): int =\\n  return a - b\\n\\n\\tNotice how the plus procedure now has an asterisk (*) after it’s name, this tells Nim that another file importing this one will be able to use this procedure.\\n\\tBy contrast this will not be visible when importing this file.", "\\nimport firstFile\\n\\necho plus(5, 10)\\necho minus(10, 5) # error\\n\\n\\tHere we import firstFile.nim. We don’t need to put the .nim extension on here.\\n\\tThis will work fine and output 15 as it’s declared in firstFile and visible to us.\\n\\tHowever this will throw an error as the minus procedure is not visible since it doesn’t have an asterisk behind it’s name.", "In case you have more than these two files, you might want to organize them in a subdirectory (or more than one subdirectory). With the following directory structure:\\n\\n.\\n├── myOtherSubdir\\n│   ├── fifthFile.nim\\n│   └── fourthFile.nim\\n├── mySubdir\\n│   └── thirdFile.nim\\n├── firstFile.nim\\n└── secondFile.nim\\n\\nif you wanted to import all other files in your secondFile.nim this is how you would do it:\\nsecondFile.nim\\n\\nimport firstFile\\nimport mySubdir/thirdFile\\nimport myOtherSubdir / [fourthFile, fifthFile]"],"exercises": [{"exercise":"What should you type to use the content of a module?\\n\\n\\n\\na:\\texport moduleName\\nb:\\timport moduleName\\nc:\\tinclude moduleName\\nd:\\texclude moduleName","type":"radio","answer":"c"}, {"exercise":"Which character exports a symbol from a module?","type":"text","answer":"*"}, {"exercise":"The following structure is given:\\n.\\n├── myOtherSubdir\\n│   ├── fifthFile.nim\\n│   └── fourthFile.nim\\n├── mySubdir\\n│   └── thirdFile.nim\\n├── firstFile.nim\\n└── secondFile.nim\\n\\nHow can you import fourthFile.nim when we are in thirdFile.nim?","type":"text","answer":"import ../myOtherSubdir/fourthFile"}], "progress":0 },
  {"order": 9,"title":"Interacting with user input","texts": ["Using the stuff we’ve introduced so far (basic data types and containers, control flow, loops) allows us to make quite a few simple programs.\\n\\nIn this chapter we will learn how to make our programs more interactive. For that we need an option to read data from a file, or ask a user for an input.", "Reading from a file\\n\\nLet’s say we have a text file called people.txt in the same directory as our Nim code. The contents of that file looks like this:\\npeople.txt\\n\\nAlice A.\\nBob B.\\nCarol C.\\n\\nWe want to use the contents of that file in our program, as a list (sequence) of names.\\n\\nimport strutils\\n\\nlet contents = readFile(\"people.txt\")\\necho contents\\n\\nlet people = contents.splitLines()\\necho people\\n\\n\\tTo read contents of a file, we use the readFile procedure, and we provide a path to the file from which to read (if the file is in the same directory as our Nim program, providing a filename is enough). The result is a multiline string.\\n\\tTo split a multiline string into a sequence of strings (each string contains all the contents of a single line) we use splitLines from the strutils module.", "Alice A.\\nBob B.\\nCarol C.\\n\\n@[\"Alice A.\", \"Bob B.\", \"Carol C.\", \"\"]\\n\\n\\tThere was a final new line (empty last line) in the original file, which is also present here.\\n\\tBecause of the final new line, our sequence is longer than we expected/wanted.\\n\\nTo solve the problem of a final new line, we can use the strip procedure from strutils after we have read from a file. All this does is remove any so-called whitespace from the start and end of our string. Whitespace is simply any character that makes some space, new-lines, spaces, tabs, etc.\\n\\nimport strutils\\n\\nlet contents = readFile(\"people.txt\").strip()\\necho contents\\n\\nlet people = contents.splitLines()\\necho people\\n\\n\\tUsing strip provides the expected results.\\n\\nAlice A.\\nBob B.\\nCarol C.\\n@[\"Alice A.\", \"Bob B.\", \"Carol C.\"]", "Reading user input\\n\\nIf we want to interact with a user, we must be able to ask them for an input, and then process it and use it. We need to read from standard input (stdin) by passing stdin to the readLine procedure.\\necho \"Please enter your name:\"\\nlet name = readLine(stdin)\\n\\necho \"Hello \", name, \", nice to meet you!\"\\n\\n\\tThe type of name is inferred to be a string.\\n\\nPlease enter your name:\\n\\n\\n\\tWaiting for user input. After we write our name and press Enter, the program will continue.\\n\\nPlease enter your name:\\nAlice\\nHello Alice, nice to meet you!", "If you are using an outdated version of VS Code, you cannot run this the usual way (using Ctrl+Alt+N) because output window doesn’t allow user inputs — you need to run these examples in the terminal.\\nWith the newer versions of VS Code there is no such limitation.", "Dealing with numbers\\nReading from a file or from a user input always gives a string as a result. If we would like to use numbers, we need to convert strings to numbers: we again use the strutils module and use parseInt to convert to integers or parseFloat to convert into a float.\\n\\nimport strutils\\n\\necho \"Please enter your year of birth:\"\\nlet yearOfBirth = readLine(stdin).parseInt()\\n\\nlet age = 2018 - yearOfBirth\\n\\necho \"You are \", age, \" years old.\"\\n\\n\\tConvert a string to an integer. When written like this, we trust our user to give a valid integer. What would happen if a user inputs '79 or ninety-three? Try it yourself.\\n\\nPlease enter your year of birth:\\n1934\\nYou are 84 years old.", "If we have file numbers.txt in the same directory as our Nim code, with the following content:\\n27.3\\n98.24\\n11.93\\n33.67\\n55.01\\n\\nand we want to read that file and find the sum and average of the numbers provided, we can do something like this:\\n\\nimport strutils, sequtils, math\\n\\nlet\\n  strNums = readFile(\"numbers.txt\").strip().splitLines()\\n  nums = strNums.map(parseFloat)\\n\\nlet\\n  sumNums = sum(nums)\\n  average = sumNums / float(nums.len)\\n\\necho sumNums\\necho average\\n\\n\\tWe import multiple modules. strutils gives us strip and splitLines, sequtils gives map, and math gives sum.\\n\\tWe strip the final new line, and split lines to create a sequence of strings.\\n\\tmap works by applying a procedure (in this case parseFloat) to each member of a container. In other words, we convert each string to a float, returning a new sequence of floats.\\n\\tUsing sum from math module to give us the sum of all elements in a sequence.\\n\\tWe need to convert the length of a sequence to float, because sumNums is a float.\\n\\n226.15\\n45.23"],"exercises": [{"exercise": ["z?"],"type":["text"],"answer": ["z"]}], "progress":0 },
  {"order": 10,"title":"Conclusions","texts": ["It is time to conclude this tutorial. Hopefully this has been useful to you, and you managed to make your first steps in programming and/or the Nim programming language.\\n\\nThese have only been the basics and we’ve only scratched the surface, but this should be enough to enable you to make simple programs and solve some simple tasks or puzzles. Nim has a lot more to offer, and hopefully you will continue to explore its possibilities.\\n\\n\\nNext steps\\n\\nIf you want to continue learning from Nim tutorials:\\n\\n\\tOfficial Nim tutorial https://bit.ly/Nim_official_tutorial \\n\\n\\tNim by example https://nim-by-example.github.io/ \\n\\nIf you want to solve some programming puzzles:\\n\\n\\tAdvent of Code: Series of interesting puzzles released every December. https://adventofcode.com \\n\\n\\tProject Euler: Mostly mathematical tasks.https://projecteuler.net/ \\n\\nHappy coding!"], "progress":0 }
]